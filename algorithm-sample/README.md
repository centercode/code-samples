# 算法学习笔记

## 二叉树

### 概念

根节点：位于二叉树顶层的节点，没有父节点。

叶子节点：没有子节点的节点。

节点所在的层：从顶至底递增，根节点所在层为 1 。

节点的度：节点的子节点的数量。在二叉树中度的取值范围是： 0、1、2 。

节点的深度：从根节点到该节点所经过的边的数量。

节点的高度：从最远叶节点到该节点所经过的边的数量。

二叉树的高度（或深度）：从根节点到最远叶节点所经过的边的数量。

满二叉树：深度为h且有2<sup>h</sup>-1个节点的二叉树。

完全二叉树：深度为h，有n个节点的二叉树，当且仅当每一个节点都与深度为h的满二叉树中编号从1至n的节点一一对应。

### 性质

1. 在二叉树的第i层上最多有2<sup>i</sup>个节点（i>=0）。
2. 深度为h的二叉树最多有2<sup>h</sup>-1个节点（h>=1）。
3. 如果叶子节点数为n0，度为2的节点数为n2,则n0=n2+1。
4. 具有n个节点的完全二叉树的深度为⌊log<sub>2</sub>n⌋+1。
5. 完全二叉树按层序编号，节点i的左子结点编号是2i+1，右子结点编号是2i+2，父节点编号是(i-1)/2（i>=0）。

## 哈夫曼树

### 概念

树的带权路径长度：树中所有叶子节点的带权路径长度之和。

哈夫曼树（最优二叉树）：带权路径长度之和最小的二叉树。

前缀编码：任一个字符的编码都不是另一个字符的编码的前缀的编码方式。

哈夫曼编码：以n种字符出现的频率作权，设计一颗哈夫曼树而得到的二进制前缀编码。

## 二叉搜索树

### 概念

二叉搜索树：空树，或者具有下列性质的二叉树：

1) 若左子树不为空，则左子树中所有节点的值均小于根节点的值
2) 若右子树不为空，右子树中所有节点的值均大于根节点的值
3) 它的左右子树也分别为二叉搜索树

### 性质

二叉搜索树的中序遍历序列是升序的。

### 时间复杂度

| 操作     | 时间复杂度                                     |
| ------- | --------------------------------------------- |
| 查找节点 | 左右子树平衡情况下：O(log n)，最坏情况下：O(n) |
| 插入节点 | 左右子树平衡情况下：O(log n)，最坏情况下：O(n) |
| 删除节点 | 左右子树平衡情况下：O(log n)，最坏情况下：O(n) |

## 排序算法

### 简介

冒泡排序：通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。

选择排序：开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。

插入排序：在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。它的工作原理与手动整理一副牌的过程非常相似。

希尔排序：

归并排序：基于分治策略的排序算法，“划分”和“合并”阶段：

1. **划分阶段**：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。
2. **合并阶段**：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。

快速排序：快速排序的核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。

堆排序：基于堆数据结构实现的高效排序算法。可以利用“建堆操作”和“元素出堆操作”实现堆排序。

计数排序：

桶排序：设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。

基数排序：

### 对比

| 排序算法 | 时间复杂度 | 最好情况时间复杂度 | 最坏情况时间复杂度 | 空间复杂度 | 排序方式  | 稳定 |
| -------- | ---------- | ------------------ | ------------------ | ---------- | --------- | ---- |
| 冒泡排序 | O(n2)      | O(n)               | O(n2)              | O(1)       | In-place  | YES  |
| 选择排序 | O(n2)      | O(n2)              | O(n2)              | O(1)       | In-place  | NO   |
| 插入排序 | O(n2)      | O(n)               | O(n2)              | O(1)       | In-place  | YES  |
| 希尔排序 | O(nlogn)   | O(nlogn)           | O(nlogn)           | O(1)       | In-place  | NO   |
| 归并排序 | O(nlogn)   | O(nlogn)           | O(nlogn)           | O(n)       | Out-place | YES  |
| 快速排序 | O(nlogn)   | O(nlogn)           | O(n2)              | O(logn)    | In-place  | NO   |
| 堆排序   | O(nlogn)   | O(nlogn)           | O(nlogn)           | O(1)       | In-place  | NO   |
| 计数排序 | O(n+k)     | O(n+k)             | O(n+k)             | O(k)       | Out-place | YES  |
| 桶排序   | O(n+k)     | O(n+k)             | O(n2)              | O(n+k)     | Out-place | YES  |
| 基数排序 | O(n×k)     | O(n×k)             | O(n×k)             | O(n+k)     | Out-place | YES  |

稳定的排序算法：冒泡排序、插入排序、归并排序、计数排序、桶排序、基数排序。

不稳定的排序算法：选择排序、希尔排序、快速排序、堆排序。





### 参考

[第 11 章   排序](https://www.hello-algo.com/chapter_sorting/)

[常用排序算法详解](https://leetcode.cn/circle/discuss/FLmgaW/)

## 数学公式

### 余数运算公式

余运算相关的公式有：

1. 除法求余公式：a = b * q + r，其中a是被除数，b是除数，q是商，r是余数。
2. 余数的性质：对于任意整数a和正整数b，有a ≡ r (mod b)，其中r是a除以b的余数。
3. 同余定理：如果a ≡ b (mod m)，则对于任意整数c，有a + c ≡ b + c (mod m)，a - c ≡ b - c (mod m)，ac ≡ bc (mod m)。
4. 余数的加法：(a + b) mod m = (a mod m + b mod m) mod m。
5. 余数的乘法：(a * b) mod m = (a mod m * b mod m) mod m。
6. 余数的幂运算：a^b mod m = ((a mod m)^b) mod m。
7. 模反元素：如果a和m互质，那么存在一个整数b，使得ab ≡ 1 (mod m)，b被称为a的模反元素。
8. 费马小定理：如果p是质数，a是整数且不是p的倍数，那么a^(p-1) ≡ 1 (mod p)。

这些公式可以用于求解余数相关的问题，例如模运算、同余方程等。

### 等比数列

等比数列首项为a，公比为q，前n项和：Sn=a * (1-q<sup>n</sup>) / (1-q)

### 排列组合

排列的定义：从n个不同元素中任取m个，按一定顺序排成一列，所有排列的个数记作：A(n,m)

组合的定义：从n个不同元素中任取m个的组合数（顺序无关）记作：C(n,m)

```
A(n,m)=n(n-1)(n-2)…(n-m+1)=n!/(n-m)!
C(n,m)=n(n-1)(n-2)…(n-m+1)÷(m!)=A(n,m)÷A(m,m)
C(n,m)=C(n,n-m)
```

